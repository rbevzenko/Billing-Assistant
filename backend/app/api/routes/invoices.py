
from datetime import date
from decimal import Decimal

from fastapi import APIRouter, Depends, HTTPException, Query, status
from sqlalchemy.orm import Session, selectinload

from app.api.deps import PaginationParams
from app.db.database import get_db
from app.models.client import Client
from app.models.enums import InvoiceStatus, TimeEntryStatus
from app.models.invoice import Invoice
from app.models.invoice_item import InvoiceItem
from app.models.lawyer_profile import LawyerProfile
from app.models.time_entry import TimeEntry
from app.schemas.common import Page
from app.schemas.invoice import InvoiceCreateRequest, InvoiceRead, InvoiceUpdate

router = APIRouter()

_LOAD_ITEMS = selectinload(Invoice.items)


def _get_or_404(invoice_id: int, db: Session) -> Invoice:
    invoice = db.query(Invoice).options(_LOAD_ITEMS).filter(Invoice.id == invoice_id).first()
    if invoice is None:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Счёт с id={invoice_id} не найден",
        )
    return invoice


def _require_draft(invoice: Invoice) -> None:
    if invoice.status != InvoiceStatus.draft:
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail=f"Операция доступна только для счёта в статусе draft. Текущий статус: {invoice.status.value}",
        )


@router.get(
    "",
    response_model=Page[InvoiceRead],
    summary="Список счетов",
)
def list_invoices(
    client_id: int | None = Query(None, description="Фильтр по клиенту"),
    invoice_status: InvoiceStatus | None = Query(None, alias="status", description="Фильтр по статусу"),
    date_from: date | None = Query(None, description="Дата выставления — начало периода"),
    date_to: date | None = Query(None, description="Дата выставления — конец периода"),
    pagination: PaginationParams = Depends(),
    db: Session = Depends(get_db),
) -> Page[InvoiceRead]:
    q = db.query(Invoice).options(_LOAD_ITEMS)

    if client_id is not None:
        q = q.filter(Invoice.client_id == client_id)
    if invoice_status is not None:
        q = q.filter(Invoice.status == invoice_status)
    if date_from is not None:
        q = q.filter(Invoice.issue_date >= date_from)
    if date_to is not None:
        q = q.filter(Invoice.issue_date <= date_to)

    total = q.count()
    items = (
        q.order_by(Invoice.issue_date.desc(), Invoice.id.desc())
        .offset(pagination.offset)
        .limit(pagination.size)
        .all()
    )
    return Page.create(items=items, total=total, page=pagination.page, size=pagination.size)


@router.post(
    "",
    response_model=InvoiceRead,
    status_code=status.HTTP_201_CREATED,
    summary="Создать счёт из записей времени",
    description=(
        "Принимает список `time_entry_ids` (все должны быть в статусе **confirmed**). "
        "Создаёт счёт и строки позиций; записи переводятся в статус **billed**. "
        "Ставка берётся из проекта, при отсутствии — из профиля юриста."
    ),
    responses={
        404: {"description": "Клиент или записи времени не найдены"},
        409: {"description": "Часть записей не в статусе confirmed"},
        422: {"description": "Ошибка валидации"},
    },
)
def create_invoice(
    data: InvoiceCreateRequest,
    db: Session = Depends(get_db),
) -> Invoice:
    # Validate client
    if db.get(Client, data.client_id) is None:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Клиент с id={data.client_id} не найден",
        )

    # Load and validate time entries
    entries = (
        db.query(TimeEntry)
        .filter(TimeEntry.id.in_(data.time_entry_ids))
        .all()
    )
    found_ids = {e.id for e in entries}
    missing = set(data.time_entry_ids) - found_ids
    if missing:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Записи времени не найдены: {sorted(missing)}",
        )

    not_confirmed = [e for e in entries if e.status != TimeEntryStatus.confirmed]
    if not_confirmed:
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail=(
                f"Записи {[e.id for e in not_confirmed]} не в статусе confirmed. "
                "Подтвердите записи перед выставлением счёта."
            ),
        )

    # Get default rate from lawyer profile
    profile = db.query(LawyerProfile).first()
    default_rate = profile.default_hourly_rate if profile else Decimal("0")

    # Create Invoice (invoice_number is generated by after_insert event)
    invoice = Invoice(
        client_id=data.client_id,
        issue_date=data.issue_date,
        due_date=data.due_date,
        status=InvoiceStatus.draft,
        notes=data.notes,
    )
    db.add(invoice)
    db.flush()  # triggers after_insert → sets invoice_number

    # Create InvoiceItems and mark entries as billed
    for entry in entries:
        rate = entry.project.hourly_rate if entry.project.hourly_rate is not None else default_rate
        amount = entry.duration_hours * rate
        db.add(
            InvoiceItem(
                invoice_id=invoice.id,
                time_entry_id=entry.id,
                hours=entry.duration_hours,
                rate=rate,
                amount=amount,
            )
        )
        entry.status = TimeEntryStatus.billed

    db.commit()

    # Reload with items to satisfy response_model
    return db.query(Invoice).options(_LOAD_ITEMS).filter(Invoice.id == invoice.id).one()


@router.get(
    "/{invoice_id}",
    response_model=InvoiceRead,
    summary="Получить счёт с позициями",
    responses={404: {"description": "Счёт не найден"}},
)
def get_invoice(invoice_id: int, db: Session = Depends(get_db)) -> Invoice:
    return _get_or_404(invoice_id, db)


@router.put(
    "/{invoice_id}",
    response_model=InvoiceRead,
    summary="Обновить счёт",
    description="Обновление доступно только для счёта в статусе **draft**.",
    responses={
        404: {"description": "Счёт не найден"},
        409: {"description": "Счёт не в статусе draft"},
    },
)
def update_invoice(
    invoice_id: int,
    data: InvoiceUpdate,
    db: Session = Depends(get_db),
) -> Invoice:
    invoice = _get_or_404(invoice_id, db)
    _require_draft(invoice)

    for field, value in data.model_dump(exclude_unset=True).items():
        setattr(invoice, field, value)
    db.commit()
    db.refresh(invoice)
    return invoice


@router.delete(
    "/{invoice_id}",
    status_code=status.HTTP_204_NO_CONTENT,
    response_model=None,
    summary="Удалить счёт",
    description=(
        "Удаление доступно только для счёта в статусе **draft**. "
        "При удалении все привязанные записи времени возвращаются в статус **confirmed**."
    ),
    responses={
        404: {"description": "Счёт не найден"},
        409: {"description": "Счёт не в статусе draft"},
    },
)
def delete_invoice(invoice_id: int, db: Session = Depends(get_db)) -> None:
    invoice = _get_or_404(invoice_id, db)
    _require_draft(invoice)

    # Revert billed time entries to confirmed
    for item in invoice.items:
        if item.time_entry_id is not None:
            entry = db.get(TimeEntry, item.time_entry_id)
            if entry is not None:
                entry.status = TimeEntryStatus.confirmed

    db.delete(invoice)
    db.commit()


@router.post(
    "/{invoice_id}/send",
    response_model=InvoiceRead,
    summary="Отправить счёт",
    description="Переводит счёт из статуса **draft** в **sent**.",
    responses={
        404: {"description": "Счёт не найден"},
        409: {"description": "Счёт не в статусе draft"},
    },
)
def send_invoice(invoice_id: int, db: Session = Depends(get_db)) -> Invoice:
    invoice = _get_or_404(invoice_id, db)
    _require_draft(invoice)

    invoice.status = InvoiceStatus.sent
    db.commit()
    db.refresh(invoice)
    return invoice


@router.post(
    "/{invoice_id}/pay",
    response_model=InvoiceRead,
    summary="Отметить счёт как оплаченный",
    description="Переводит счёт из статуса **sent** в **paid**.",
    responses={
        404: {"description": "Счёт не найден"},
        409: {"description": "Счёт не в статусе sent"},
    },
)
def pay_invoice(invoice_id: int, db: Session = Depends(get_db)) -> Invoice:
    invoice = _get_or_404(invoice_id, db)

    if invoice.status != InvoiceStatus.sent:
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail=f"Оплатить можно только счёт в статусе sent. Текущий статус: {invoice.status.value}",
        )

    invoice.status = InvoiceStatus.paid
    db.commit()
    db.refresh(invoice)
    return invoice
